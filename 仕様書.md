# 運送アプリケーション開発シナリオ

## 1. システム概要

顧客の注文から配達業者による配達完了までを管理する運送管理システムを、テスト駆動開発(TDD)で構築します。

## 2. ドメイン概念の整理

### 2.1 主要なエンティティ

### 顧客 (Customer)

- 顧客ID
- 氏名
- 住所
- 電話番号
- メールアドレス

### 注文 (Order)

- 注文ID
- 顧客ID
- 注文日時
- 配送元住所
- 配送先住所
- 荷物の詳細（サイズ、重量、品名）
- ステータス（注文受付、配達業者割り当て済み、配達中、配達完了、キャンセル）
- 希望配達日時

### 配達業者 (Driver)

- 業者ID
- 氏名
- 電話番号
- 現在のステータス（待機中、配達中、休憩中）
- 担当エリア

### 配達 (Delivery)

- 配達ID
- 注文ID
- 配達業者ID
- 配達開始日時
- 配達完了日時
- ステータス（未割り当て、割り当て済み、配達中、配達完了、配達失敗）
- 配達証明（受取人署名、写真など）

## 3. ユースケース一覧

### 3.1 注文関連

1. **注文を作成する**
- 入力: 顧客情報、配送元、配送先、荷物詳細、希望配達日時
- 出力: 注文ID、注文確認情報
- ビジネスルール:
    - 配送元と配送先が同じ住所の場合はエラー
    - 希望配達日時は現在時刻より未来であること
    - 荷物の重量・サイズに上限がある
1. **注文をキャンセルする**
- 入力: 注文ID
- 出力: キャンセル完了通知
- ビジネスルール:
    - 配達中または配達完了の注文はキャンセルできない
    - キャンセル料が発生する場合がある（配達業者割り当て後）
1. **注文詳細を照会する**
- 入力: 注文ID
- 出力: 注文の詳細情報、現在のステータス

### 3.2 配達業者割り当て関連

1. **配達業者を自動割り当てする**
- 入力: 注文ID
- 出力: 割り当てられた配達業者情報
- ビジネスルール:
    - 配送先エリアを担当している業者から選択
    - 待機中の業者を優先
    - 業者が見つからない場合はエラー
1. **配達業者を手動で割り当てる**
- 入力: 注文ID、配達業者ID
- 出力: 割り当て完了通知
- ビジネスルール:
    - 指定された業者が配達中でないこと
    - 指定された業者が担当エリア内であること

### 3.3 配達実行関連

1. **配達を開始する**
- 入力: 配達ID、配達業者ID
- 出力: 配達開始確認
- ビジネスルール:
    - 配達業者が割り当て済みであること
    - 同じ業者が複数の配達を同時に実行できない
1. **配達を完了する**
- 入力: 配達ID、配達完了日時、配達証明データ
- 出力: 配達完了確認
- ビジネスルール:
    - 配達が開始されていること
    - 配達証明が必須（受取人署名など）
    - 配達完了時刻が配達開始時刻より後であること
1. **配達失敗を記録する**
- 入力: 配達ID、失敗理由
- 出力: 配達失敗記録
- ビジネスルール:
    - 不在、住所不明、受取拒否などの理由を記録
    - 再配達の可否を判定

### 3.4 照会・検索関連

1. **顧客の注文履歴を照会する**
- 入力: 顧客ID
- 出力: 注文リスト（最新順）
1. **配達業者の配達履歴を照会する**
- 入力: 配達業者ID、期間（開始日、終了日）
- 出力: 配達リスト
1. **特定ステータスの注文を検索する**
- 入力: ステータス
- 出力: 該当する注文リスト

## 4. ドメイン層の主要な関数（純粋関数）

### 4.1 Order関連

- `create-order`: 注文を作成
- `cancel-order`: 注文をキャンセル
- `validate-order`: 注文内容のバリデーション
- `can-cancel-order?`: 注文がキャンセル可能か判定
- `update-order-status`: 注文ステータスを更新
- `calculate-delivery-fee`: 配送料を計算

### 4.2 Delivery関連

- `create-delivery`: 配達を作成
- `start-delivery`: 配達を開始
- `complete-delivery`: 配達を完了
- `fail-delivery`: 配達失敗を記録
- `validate-delivery-completion`: 配達完了のバリデーション
- `calculate-delivery-duration`: 配達所要時間を計算

### 4.3 Driver関連

- `assign-driver-to-delivery`: 配達業者を割り当て
- `can-assign-driver?`: 配達業者が割り当て可能か判定
- `update-driver-status`: 配達業者のステータス更新
- `find-available-drivers`: 利用可能な配達業者を検索

## 5. ユースケース層の主要な関数

各ユースケースは以下のような構造を持ちます：

```
入力の受付 → ポート経由でデータ取得 → ドメイン層で処理 → ポート経由でデータ保存 → 結果を返却

```

### 5.1 注文ユースケース

- `place-order-usecase`: 注文作成の処理フロー全体を orchestrate
- `cancel-order-usecase`: 注文キャンセルの処理フロー
- `get-order-details-usecase`: 注文詳細照会

### 5.2 配達割り当てユースケース

- `auto-assign-driver-usecase`: 自動割り当てロジック
- `manual-assign-driver-usecase`: 手動割り当てロジック

### 5.3 配達実行ユースケース

- `start-delivery-usecase`: 配達開始処理
- `complete-delivery-usecase`: 配達完了処理
- `fail-delivery-usecase`: 配達失敗処理

### 5.4 照会ユースケース

- `get-customer-orders-usecase`: 顧客の注文履歴照会
- `get-driver-deliveries-usecase`: 配達業者の配達履歴照会
- `search-orders-by-status-usecase`: ステータス別注文検索

## 6. Port/Gateway インターフェース

### 6.1 データ取得用ポート

- `order-repository`: 注文データの取得・保存
- `customer-repository`: 顧客データの取得
- `driver-repository`: 配達業者データの取得・更新
- `delivery-repository`: 配達データの取得・保存

### 6.2 メモリ上のサンプルデータ

テスト用に以下のサンプルデータを用意：

### 顧客サンプル

- 顧客A: 東京都渋谷区在住
- 顧客B: 東京都新宿区在住
- 顧客C: 神奈川県横浜市在住

### 配達業者サンプル

- 業者1: 東京都23区担当、待機中
- 業者2: 東京都23区担当、配達中
- 業者3: 神奈川県担当、待機中

## 7. テストシナリオ例

### 7.1 正常系: 注文から配達完了までの一連の流れ

1. 顧客Aが渋谷区から新宿区への配送を注文
2. システムが配送料を計算
3. 注文が作成される（ステータス: 注文受付）
4. 利用可能な配達業者を検索（業者1が該当）
5. 業者1を自動割り当て（ステータス: 配達業者割り当て済み）
6. 業者1が配達を開始（ステータス: 配達中）
7. 業者1が配達を完了（ステータス: 配達完了）
8. 配達所要時間を記録

### 7.2 準正常系: 注文後のキャンセル

1. 顧客Bが注文を作成
2. 配達業者割り当て前に顧客がキャンセルを依頼
3. キャンセル可能かチェック（→ 可能）
4. 注文をキャンセル（ステータス: キャンセル）

### 7.3 異常系: 配達中の注文をキャンセルしようとする

1. 顧客Cの注文に業者3が割り当て済み
2. 業者3が配達を開始
3. 顧客がキャンセルを依頼
4. キャンセル可能かチェック（→ 不可）
5. エラーメッセージを返す

### 7.4 異常系: 配達業者が見つからない

1. 顧客Aが北海道への配送を注文
2. 北海道担当の配達業者を検索
3. 該当する業者が見つからない
4. エラーメッセージを返す

### 7.5 異常系: 配達完了時のバリデーションエラー

1. 業者1が配達を開始
2. 配達証明なしで完了しようとする
3. バリデーションでエラー
4. 配達証明が必要である旨のメッセージを返す

## 8. 開発の進め方（TDD）

### フェーズ1: ドメイン層の開発

1. Order関連の関数をテストファースト で実装
2. Delivery関連の関数を実装
3. Driver関連の関数を実装

### フェーズ2: ポート/ゲートウェイのモック実装

1. メモリベースのリポジトリを実装
2. サンプルデータを用意

### フェーズ3: ユースケース層の開発

1. 注文ユースケースを実装
2. 配達割り当てユースケースを実装
3. 配達実行ユースケースを実装
4. 照会ユースケースを実装

### フェーズ4: 統合テスト

1. エンドツーエンドのシナリオテストを実装
2. 各異常系のテストを追加

## 9. プロジェクト構成（推奨）

```
delivery-app/
├── src/
│   ├── domain/
│   │   ├── order.clj
│   │   ├── delivery.clj
│   │   └── driver.clj
│   ├── usecase/
│   │   ├── order_usecase.clj
│   │   ├── delivery_usecase.clj
│   │   └── query_usecase.clj
│   └── port/
│       └── repository.clj (protocol定義)
├── test/
│   ├── domain/
│   │   ├── order_test.clj
│   │   ├── delivery_test.clj
│   │   └── driver_test.clj
│   ├── usecase/
│   │   ├── order_usecase_test.clj
│   │   ├── delivery_usecase_test.clj
│   │   └── query_usecase_test.clj
│   └── integration/
│       └── scenario_test.clj
└── dev/
    └── sample_data.clj (メモリベースのサンプルデータ)

```

## 10. 次のステップ

このシナリオを基に、以下の順序で開発を進めることをお勧めします：

1. **ドメインモデルの定義**: 各エンティティのスキーマ（spec使用）を定義
2. **ドメイン層のテスト作成**: 最も小さな関数から始める
3. **ドメイン層の実装**: テストを通す
4. **サンプルデータの作成**: テスト用のフィクスチャ
5. **ユースケース層のテスト作成**: モックリポジトリを使用
6. **ユースケース層の実装**: ドメイン関数を組み合わせる
7. **統合テスト**: 実際のシナリオを通したテスト

必要に応じて各フェーズを詳細化し、段階的に開発を進めていきましょう。