# テストアサーションガイド: `is`、`true?`、`match?` の使い分け

## 概要

Clojureのテストで使う主要なアサーション機能の使い分けを説明します。

---

## 1. `is` - テストの検証マクロ

### 役割
`is` は **Clojure標準のテストライブラリ（`clojure.test`）のアサーションマクロ**です。
テストで「期待する結果になっているか」を検証するための基本機能です。

### 基本的な使い方

```clojure
(ns my-test
  (:require [clojure.test :refer :all]))

(deftest example-test
  ;; 基本的な検証
  (is true)                    ; ✅ true ならテストが通る
  (is false)                   ; ❌ false だとテストが失敗する
  
  ;; 等価性のチェック
  (is (= 1 1))                 ; ✅ 1 と 1 が等しいかチェック
  (is (= {:a 1} {:a 1}))      ; ✅ マップの完全一致
  
  ;; 関数の結果をチェック
  (is (true? (some-function))) ; ✅ some-function が true を返すかチェック
  (is (nil? (some-function))) ; ✅ some-function が nil を返すかチェック
)
```

### 特徴
- **標準ライブラリ**: 追加の依存関係不要
- **どんな値でも検証可能**: 真偽値、数値、文字列、マップ、コレクションなど
- **完全一致が必要**: マップの場合は、すべてのキーと値が一致する必要がある

### 例

```clojure
(deftest order-status-test
  (testing "注文のステータスが正しいか"
    (let [order {:order-id "ORD-001"
                  :status :注文受付}]
      ;; 完全一致が必要
      (is (= :注文受付 (:status order)))  ; ✅ 正しい
      (is (= {:status :注文受付} order))   ; ❌ 他のキーがあると失敗
      )))
```

---

## 2. `true?` - 真偽値チェック関数

### 役割
`true?` は **Clojure標準の関数**で、値が `true` かどうかをチェックします。

### 基本的な使い方

```clojure
(true? true)    ; => true
(true? false)   ; => false
(true? nil)     ; => false
(true? 1)       ; => false
```

### `is` と組み合わせて使う

```clojure
(deftest can-cancel-order-test
  (testing "注文がキャンセル可能か"
    (let [order {:status :注文受付}]
      ;; true? で関数の結果が true かチェック
      (is (true? (can-cancel-order? order)))  ; ✅ 推奨
      
      ;; 以下も同じ意味だが、true? の方が明示的
      (is (can-cancel-order? order))          ; ✅ でも動作する
      )))
```

### 類似関数
- `false?`: 値が `false` かどうか
- `nil?`: 値が `nil` かどうか
- `some?`: 値が `nil` でないかどうか

### 使い分け

```clojure
;; ✅ 推奨：明示的に true を期待していることを示す
(is (true? (can-cancel-order? order)))

;; ✅ でも動作する：関数が truthy な値を返すことを期待
(is (can-cancel-order? order))

;; ❌ 避ける：意図が不明確
(is (= true (can-cancel-order? order)))
```

---

## 3. `match?` - 柔軟な比較関数

### 役割
`match?` は **`matcher-combinators` ライブラリの関数**で、マップやコレクションを柔軟に比較できます。
通常の `=` より柔軟で、特に**マップの一部だけをチェック**したり、**型をチェック**したりするのに便利です。

### 必要な依存関係

```clojure
;; project.clj
:dependencies [[nubank/matcher-combinators "3.9.1"]]
```

### 基本的な使い方

```clojure
(ns my-test
  (:require [clojure.test :refer :all]
            [matcher-combinators.test :refer [match?]]))

(deftest example-test
  ;; match? は必ず is の中で使う
  (is (match? 期待値 実際の値))
)
```

### 主な機能

#### 1. マップの一部だけをチェック

```clojure
(deftest order-test
  (let [order {:order-id "ORD-001"
               :customer-id "CUST-001"
               :status :注文受付
               :from-address "東京都..."
               :to-address "東京都..."}]
    
    ;; ✅ 一部のキーだけチェック（他のキーがあってもOK）
    (is (match? {:status :注文受付}
                order))  ; ✅ 他のキーがあってもOK
    
    ;; ✅ 複数のキーをチェック
    (is (match? {:status :注文受付
                 :customer-id "CUST-001"}
                order))
    
    ;; ❌ is だけだと完全一致が必要
    (is (= {:status :注文受付} order))  ; ❌ 他のキーがあると失敗
    ))
```

#### 2. 型チェック

```clojure
(deftest order-creation-test
  (let [order (create-order ...)]
    ;; ✅ 型をチェックできる
    (is (match? {:order-id string?      ; string? という型をチェック
                  :status :注文受付
                  :customer-id string?}
                 order))
    
    ;; ✅ 数値の型チェック
    (is (match? {:weight number?
                 :price number?}
                package))
    ))
```

#### 3. コレクションの比較

```clojure
(deftest validation-test
  (let [result {:valid? false
                :errors ["エラー1" "エラー2" "エラー3"]}]
    ;; ✅ ベクターの要素をチェック
    (is (match? {:valid? false
                  :errors [string? string? string?]}  ; 3つの文字列
                 result))
    
    ;; ✅ 任意の数の要素をチェック
    (is (match? {:errors [string? ...]}  ; 1つ以上の文字列
                 result))
    ))
```

#### 4. ネストしたマップのチェック

```clojure
(deftest nested-map-test
  (let [order {:order-id "ORD-001"
               :package {:weight 5.0
                         :size {:width 30
                                :height 20
                                :depth 15}}}]
    ;; ✅ ネストしたマップもチェックできる
    (is (match? {:order-id string?
                  :package {:weight number?
                            :size {:width number?
                                   :height number?
                                   :depth number?}}}
                 order))
    ))
```

---

## 4. 使い分けの指針

### いつ `is` だけを使うか

✅ **単純な値の比較**
```clojure
(is (= 1 1))
(is (= "hello" "hello"))
(is (= :注文受付 (:status order)))
```

✅ **真偽値のチェック**
```clojure
(is (true? (can-cancel-order? order)))
(is (false? (is-invalid? order)))
(is (nil? (find-order "non-existent-id")))
```

✅ **完全一致が必要な場合**
```clojure
;; マップ全体が完全に一致する必要がある
(is (= {:a 1 :b 2} {:a 1 :b 2}))
```

### いつ `match?` を使うか

✅ **マップの一部だけをチェックしたい**
```clojure
;; 一部のキーだけチェック（他のキーがあってもOK）
(is (match? {:status :注文受付} order))
```

✅ **型をチェックしたい**
```clojure
;; IDが文字列かどうかチェック
(is (match? {:order-id string?} order))
```

✅ **コレクションの要素をチェックしたい**
```clojure
;; エラーリストの要素が文字列かチェック
(is (match? {:errors [string? string?]} result))
```

✅ **テストを柔軟にしたい**
```clojure
;; 時間が変わるテストなど、一部の値だけをチェック
(is (match? {:order-id string?
              :status :注文受付}
             order))  ; order-datetime などはチェックしない
```

---

## 5. 実践例

### 例1: 真偽値のチェック

```clojure
(deftest can-cancel-order?-test
  (testing "注文受付中の注文はキャンセル可能"
    (let [order {:status :注文受付}]
      ;; ✅ 推奨：明示的に true を期待
      (is (true? (order/can-cancel-order? order))))
    
    (testing "配達中の注文はキャンセル不可"
      (let [order {:status :配達中}]
        ;; ✅ 推奨：明示的に false を期待
        (is (false? (order/can-cancel-order? order)))))))
```

### 例2: マップの比較

```clojure
(deftest create-order-test
  (testing "注文を作成する"
    (let [order (order/create-order "CUST-001" ...)]
      ;; ✅ match? を使う：一部だけチェック（order-id は毎回変わるので型だけチェック）
      (is (match? {:order-id string?          ; 型だけチェック
                    :customer-id "CUST-001"
                    :status :注文受付}
                   order))
      
      ;; ❌ is だけだと完全一致が必要（order-id が毎回変わるので使えない）
      ;; (is (= {:customer-id "CUST-001" ...} order))  ; これは使えない
      )))
```

### 例3: バリデーション結果のチェック

```clojure
(deftest validate-order-test
  (testing "正常な注文はバリデーション成功"
    (let [order {:from-address "東京都..."
                 :to-address "東京都..."}
          result (order/validate-order order)]
      ;; ✅ match? を使う：valid? だけチェック
      (is (match? {:valid? true} result))))
  
  (testing "エラーがある場合はエラーメッセージを返す"
    (let [order {:from-address "東京都..."
                 :to-address "東京都..."}  ; 同じ住所
          result (order/validate-order order)]
      ;; ✅ match? を使う：エラーメッセージの型をチェック
      (is (match? {:valid? false
                    :errors [string?]}  ; エラーは文字列のリスト
                   result)))))
```

### 例4: ネストしたマップのチェック

```clojure
(deftest package-test
  (testing "荷物の情報が正しいか"
    (let [order {:order-id "ORD-001"
                 :package {:weight 5.0
                           :size {:width 30
                                  :height 20
                                  :depth 15}
                           :description "書籍"}}]
      ;; ✅ match? を使う：ネストしたマップもチェック
      (is (match? {:package {:weight number?
                              :size {:width number?
                                     :height number?
                                     :depth number?}
                              :description string?}}
                   order)))))
```

---

## 6. よくある間違い

### ❌ 間違い1: `match?` を `is` で囲まない

```clojure
;; ❌ 間違い
(deftest test
  (match? {:status :注文受付} order))  ; is で囲まないとテストにならない

;; ✅ 正しい
(deftest test
  (is (match? {:status :注文受付} order)))
```

### ❌ 間違い2: 真偽値に `match?` を使う

```clojure
;; ❌ 動作するが、不要な複雑さ
(is (match? true (can-cancel-order? order)))

;; ✅ 推奨：シンプルで明示的
(is (true? (can-cancel-order? order)))
```

### ❌ 間違い3: 完全一致が必要なのに `match?` を使う

```clojure
;; 完全一致が必要な場合
(let [expected {:a 1 :b 2}
      actual {:a 1 :b 2}]
  ;; ✅ 完全一致が必要なら is と = を使う
  (is (= expected actual))
  
  ;; ❌ match? は一部だけチェックするので、予期しないキーがあっても通る
  ;; (is (match? expected actual))  ; これは避ける
  )
```

---

## 7. まとめ

| 機能 | 用途 | いつ使うか |
|------|------|-----------|
| **`is`** | テストの検証マクロ | 常に使う（必須） |
| **`true?`** | 真偽値チェック | 関数が `true` を返すことを期待するとき |
| **`match?`** | 柔軟な比較 | マップの一部だけチェック、型チェック、コレクションのチェック |

### 覚え方

1. **`is`** = テストの検証（必ず必要）
2. **`true?`** = 真偽値のチェック（シンプルな場合）
3. **`match?`** = マップやコレクションの柔軟な比較（複雑な場合）

### 基本パターン

```clojure
;; パターン1: 単純な値の比較
(is (= expected actual))

;; パターン2: 真偽値のチェック
(is (true? (some-function)))

;; パターン3: マップの一部チェック
(is (match? {:key value} map))

;; パターン4: 型チェック
(is (match? {:key type?} map))
```

---

## 参考

- [clojure.test 公式ドキュメント](https://clojure.github.io/clojure/clojure.test-api.html)
- [matcher-combinators GitHub](https://github.com/nubank/matcher-combinators)

